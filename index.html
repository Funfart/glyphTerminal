<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Glyph Terminal v3 Runtime Engine</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

<style>
body{background:black;color:#00ff88;font-family:monospace;margin:0;}
#controls{position:sticky;top:0;background:#000;padding:10px;border-bottom:1px solid #00ff88;}
textarea{width:100%;height:140px;background:#000;color:#00ff88;border:1px solid #00ff88;padding:10px;}
button,input{margin-top:6px;width:100%;background:#000;color:#00ff88;border:1px solid #00ff88;padding:6px;}
canvas{display:block;margin:10px auto;border:1px solid #00ff88;background:black;}
</style>
</head>
<body>

<div id="controls">
<textarea id="input">Welcome to Glyph Terminal v3
{ hello_world | web3 }</textarea>

<button id="translate">Encode / Decode</button>
<button id="typeToggle">Play / Pause Typing</button>
<input id="speed" type="range" min="1" max="10" value="4">
<button id="export">Export GIF</button>
</div>

<canvas id="canvas" width="1200" height="650"></canvas>

<script>

/* ================= CONFIG ================= */

const IPFS_GATEWAYS=[
"https://gold-junior-swordfish-840.mypinata.cloud/ipfs/",
"https://ipfs.io/ipfs/"
];

const CID="bafybeig6ernsujafbpe4atdrs4zu6co6t5tizcz3sgjclhlkroqzbwkekm";
const GLYPH_SIZE=32;
const LINE_HEIGHT=46;
const MARGIN=20;
const WAVE_SPEED=0.03;
const GIF_FPS=12;

/* ================= GLYPH MAP ================= */

const glyphMap={
a:"1.png",b:"2.png",c:"3.png",d:"4.png",e:"5.png",
f:"6.png",g:"7.png",h:"8.png",i:"9.png",j:"10.png",
k:"11.png",l:"12.png",m:"13.png",n:"14.png",o:"15.png",
p:"16.png",q:"17.png",r:"18.png",s:"19.png",t:"20.png",
u:"21.png",v:"22.png",w:"23.png",x:"24.png",y:"25.png",z:"26.png",
" ":"space.png","_":"under.png","{":"oBr.png","}":"cBr.png",
"(":"oB+.png",")":"cB+.png",".":"p.png",";":"semi.png",
"'":"app.png","=":"eq+.png","/":"fSlash.png","$":"crypto.png",
"\\":"cbSlash.png",":":"colon.png","<":"less.png",">":"more.png",
"!":"!.png","&":"&.png","|":"or.png","\"":"qu.png","+":"+.png",
"-":"-.png","`":"bTick.png",",":"ap.png","%":"%.png",
"0":"0.png","1":"_1.png","2":"_2.png","3":"_3.png",
"]":"cSqBr.png","[":"oSqBr.png","4":"_4.png","5":"_5.png",
"6":"_6.png","7":"_7.png","8":"_8.png","9":"_9.png"
};

/* ================= STATE ================= */

let encoded=false;
let glyphCache={};
let typing=true;
let revealIndex=0;
let time=0;

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
ctx.font="24px monospace";
ctx.textBaseline="top";
const input=document.getElementById("input");

/* ================= PRELOAD ALL GLYPHS ================= */

function preloadGlyphs(callback){

 const keys=Object.keys(glyphMap);
 let loaded=0;

 keys.forEach(k=>{

  const img=new Image();
  img.crossOrigin="anonymous";

  let gatewayIndex=0;

  function tryLoad(){

   if(gatewayIndex>=IPFS_GATEWAYS.length){
    console.warn("Missing glyph:",k);
    loaded++;
    if(loaded===keys.length) callback();
    return;
   }

   img.src=IPFS_GATEWAYS[gatewayIndex]+CID+"/"+glyphMap[k];

   img.onload=()=>{
    glyphCache[k]=img;
    loaded++;
    if(loaded===keys.length) callback();
   };

   img.onerror=()=>{
    gatewayIndex++;
    tryLoad();
   };

  }

  tryLoad();

 });

}

/* ================= TRANSLATOR ================= */

function encodeText(text){
 return text.split("").map(ch=>{
  const k=ch.toLowerCase();
  return glyphMap[k]?`[${k}]`:ch;
 }).join("");
}

function decodeTokens(text){
 return text.replace(/\[(.*?)\]/g,(m,p1)=>glyphMap[p1]?p1:m);
}

/* ================= TOKEN PARSER ================= */

function tokenize(text){
 let tokens=[];
 const regex=/\[(.*?)\]/g;
 let lastIndex=0;
 let match;

 while((match=regex.exec(text))){
  if(match.index>lastIndex){
   tokens.push(...text.slice(lastIndex,match.index).split(""));
  }
  tokens.push(match[1]);
  lastIndex=regex.lastIndex;
 }

 if(lastIndex<text.length){
  tokens.push(...text.slice(lastIndex).split(""));
 }

 return tokens;
}

/* ================= GLYPH OBJECT ================= */

class Glyph{

 constructor(char,index){
  this.char=char;
  this.index=index;
  this.state=Math.random()<0.1?"glitch":"pulse";
 }

 draw(context,x,y,t){

  let offsetY=0;
  let scale=1;

  if(this.state==="pulse"){
   scale=1+Math.sin(t+this.index*0.3)*0.05;
  }

  if(this.state==="glitch"){
   offsetY=(Math.random()-0.5)*4;
  }

  if(glyphMap[this.char]){

   const img=glyphCache[this.char];

   if(img && img.complete && img.naturalWidth>0){

    context.drawImage(
     img,
     x,
     y+offsetY,
     GLYPH_SIZE*scale,
     GLYPH_SIZE*scale
    );

   }else{

    context.fillStyle="#004422";
    context.fillRect(x,y,GLYPH_SIZE,GLYPH_SIZE);

   }

  }else{

   context.fillStyle="#00ff88";
   context.fillText(this.char,x,y+offsetY);

  }

 }
}

/* ================= RENDER ================= */

function render(){

 ctx.fillStyle="black";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 const raw=input.value;
 const decoded=decodeTokens(raw);
 const tokens=tokenize(encoded?raw:decoded);

 if(typing){
  revealIndex+=parseInt(document.getElementById("speed").value)/4;
 }

 let visible=tokens.slice(0,Math.floor(revealIndex));

 let x=MARGIN;
 let y=MARGIN;

 visible.forEach((tk,i)=>{

  if(tk==="\n"){x=MARGIN;y+=LINE_HEIGHT;return;}

  const glyph=new Glyph(tk,i);
  glyph.draw(ctx,x,y,time);

  x+=GLYPH_SIZE;

  if(x>canvas.width-MARGIN){
   x=MARGIN;
   y+=LINE_HEIGHT;
  }

 });

 time+=WAVE_SPEED;
 requestAnimationFrame(render);
}

/* ================= GIF EXPORT ================= */

async function exportGIF(){

const gif=new GIF({
workers:2,
quality:10,
workerScript:"https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"
});

const off=document.createElement("canvas");
off.width=canvas.width;
off.height=canvas.height;
const octx=off.getContext("2d");

const tokens=tokenize(encoded?input.value:decodeTokens(input.value));

let localTime=0;

for(let i=1;i<=tokens.length;i++){

octx.fillStyle="black";
octx.fillRect(0,0,off.width,off.height);

let x=MARGIN,y=MARGIN;

tokens.slice(0,i).forEach((tk,index)=>{
 const g=new Glyph(tk,index);
 g.draw(octx,x,y,localTime);
 x+=GLYPH_SIZE;
});

gif.addFrame(off,{copy:true,delay:1000/GIF_FPS});
localTime+=0.1;
}

gif.on("finished",blob=>{
const a=document.createElement("a");
a.href=URL.createObjectURL(blob);
a.download="glyph-terminal-v3.gif";
a.click();
});

gif.render();
}

/* ================= CONTROLS ================= */

document.getElementById("translate").onclick=()=>{
 if(encoded){
  input.value=decodeTokens(input.value);
 }else{
  input.value=encodeText(input.value);
 }
 encoded=!encoded;
 revealIndex=0;
};

document.getElementById("typeToggle").onclick=()=>typing=!typing;
document.getElementById("export").onclick=exportGIF;

/* ================= START ENGINE AFTER PRELOAD ================= */

preloadGlyphs(()=>{
 console.log("All glyphs preloaded.");
 render();
});

</script>
</body>
</html>
